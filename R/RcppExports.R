# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Score Sequences with PWM
#'
#' @description
#' C++ implementation of PWM scoring algorithm
#'
#' @param sequences list of sequences
#' @param pwm position weight matrix
#'
#' @return list of PWM scores for each sequence
#' @examples
#' motif <- getMotifById("M178_0.6")[[1]]
#' sequences <- c("CAACAGCCTTAATT", "CAGTCAAGACTCC", "CTTTGGGGAAT", "TCATTTTATTAAA",
#'   "AATTGGTGTCTGGATACTTCCCTGTACAT", "ATCAAATTA", "TGTGGGG", "GACACTTAAAGATCCT",
#'   "TAGCATTAACTTAATG", "ATGGA", "GAAGAGTGCTCA", "ATAGAC", "AGTTC", "CCAGTAA")
#' seq.char.vectors <- lapply(sequences, function(seq) {
#'   unlist(strsplit(seq, ""))
#' })
#' scoreSequences(seq.char.vectors, as.matrix(motif$matrix))
#'
#' @export
scoreSequences <- function(sequences, pwm) {
    .Call('_transite_scoreSequences', PACKAGE = 'transite', sequences, pwm)
}

#' @title \emph{k}-mer Score Calculation
#'
#' @description
#' C++ implementation of \emph{k}-mer score calculation
#'
#' @param kmers list of \emph{k}-mers
#' @param pwm position weight matrix
#'
#' @return list of PWM scores for the specified \emph{k}-mers
#'
#' @examples
#' motif <- getMotifById("M178_0.6")[[1]]
#' kmers <- c("AAAAAA", "CAAAAA", "GAAAAA")
#' calculateKmerScores(kmers, as.matrix(motif$matrix))
#'
#' @export
calculateKmerScores <- function(kmers, pwm) {
    .Call('_transite_calculateKmerScores', PACKAGE = 'transite', kmers, pwm)
}

#' @title \emph{k}-mer Score Lookup Table Access Function
#'
#' @description
#' C++ implementation of \emph{k}-mer score hash table lookup.
#'
#' @param kmers list of \emph{k}-mers
#' @param kmerScores position weight matrix
#'
#' @return numeric vector of \emph{k}-mer scores
lookupKmerScores <- function(kmers, kmerScores) {
    .Call('_transite_lookupKmerScores', PACKAGE = 'transite', kmers, kmerScores)
}

#' @title Motif Score Algorithm
#'
#' @description
#' C++ implementation of motif score algorithm.
#'
#' @param kmers list of \emph{k}-mers
#' @return data frame with columns \code{score}, \code{top.kmer},
#' and \code{top.kmer.enrichment}
computeMotifScore <- function(kmers) {
    .Call('_transite_computeMotifScore', PACKAGE = 'transite', kmers)
}

#' @title Local Consistency Score
#'
#' @description
#' C++ implementation of Local Consistency Score algorithm.
#'
#' @param x numeric vector that contains values for shuffling
#' @param numPermutations maximum number of permutations performed in Monte Carlo test
#' for consistency score
#' @param minPermutations minimum number of permutations performed in Monte Carlo test
#' for consistency score
#' @param e stop criterion for consistency score Monte Carlo test: aborting permutation
#' process after observing \code{e} random consistency values with more extreme values
#' than the actual consistency value
#' @return list with \code{score}, \code{p.value}, and \code{n} components
#'
#' @examples
#' poor.enrichment.spectrum <- c(0.1, 0.5, 0.6, 0.4, 0.7, 0.6, 1.2, 1.1, 1.8, 1.6)
#' local.consistency <- calculateLocalConsistency(enrichment.values, 1000000, 1000, 5)
#'
#' enrichment.spectrum <- c(0.1, 0.3, 0.6, 0.7, 0.8, 0.9, 1.2, 1.4, 1.6, 1.4)
#' local.consistency <- calculateLocalConsistency(enrichment.values, 1000000, 1000, 5)
#' @export
calculateLocalConsistency <- function(x, numPermutations, minPermutations, e) {
    .Call('_transite_calculateLocalConsistency', PACKAGE = 'transite', x, numPermutations, minPermutations, e)
}

#' @title Motif Enrichment calculation
#'
#' @description
#' C++ implementation of Motif Enrichment calculation
#'
#' @param absoluteHits number of putative binding sites per sequence
#' (returned by \code{\link{scoreTranscripts}})
#' @param totalSites number of potential binding sites per sequence
#' (returned by \code{\link{scoreTranscripts}})
#' @param relHitsForeground relative number of hits in foreground set
#' @param n number of sequences in the foreground set
#' @param maxPermutations maximum number of foreground permutations performed in
#' Monte Carlo test for enrichment score
#' @param minPermutations minimum number of foreground permutations performed in
#' Monte Carlo test for enrichment score
#' @param e stop criterion for enrichment score Monte Carlo test: aborting permutation process
#' after observing \code{e} random enrichment values with more extreme values than the actual
#' enrichment value
#'
#' @return list with p-value and number of iterations of Monte Carlo sampling
#' for local consistency score
#'
#' @examples
#' foreground.seqs <- c("CAGTCAAGACTCC", "AATTGGTGTCTGGATACTTCCCTGTACAT", "AGAT", "CCAGTAA")
#' background.seqs <- c("CAACAGCCTTAATT", "CAGTCAAGACTCC", "CTTTGGGGAAT",
#'                      "TCATTTTATTAAA", "AATTGGTGTCTGGATACTTCCCTGTACAT",
#'                      "ATCAAATTA", "AGAT", "GACACTTAAAGATCCT",
#'                      "TAGCATTAACTTAATG", "ATGGA", "GAAGAGTGCTCA",
#'                      "ATAGAC", "AGTTC", "CCAGTAA")
#' foreground.scores <- scoreTranscripts(foreground.seqs, cache = FALSE)
#' background.scores <- scoreTranscripts(background.seqs, cache = FALSE)
#'
#' fg <- dplyr::filter(foreground.scores$df, motif.id == "M178_0.6")
#' bg <- dplyr::filter(background.scores$df, motif.id == "M178_0.6")
#'
#' mc.result <- calculateTranscriptMC(bg$absolute.hits, bg$total.sites,
#'                                    fg$absolute.hits / fg$total.sites,
#'                                    length(foreground.seqs), 10000, 5000, 5)
#'
calculateTranscriptMC <- function(absoluteHits, totalSites, relHitsForeground, n, maxPermutations, minPermutations, e) {
    .Call('_transite_calculateTranscriptMC', PACKAGE = 'transite', absoluteHits, totalSites, relHitsForeground, n, maxPermutations, minPermutations, e)
}

