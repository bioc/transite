% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spectrum.R
\name{spectrumClassifier}
\alias{spectrumClassifier}
\title{Simple spectrum classifier based on empirical thresholds}
\usage{
spectrumClassifier(adj.r.squared, degree, slope, consistency.score.n,
  n.significant, n.bins)
}
\arguments{
\item{adj.r.squared}{adjusted \eqn{R^2} of polynomial model, returned by
\link{scoreSpectrum}}

\item{degree}{degree of polynomial, returned by \link{scoreSpectrum}}

\item{slope}{coefficient of the linear term of the polynomial model
(spectrum "direction"),
returned by \link{scoreSpectrum}}

\item{consistency.score.n}{number of performed permutations before
early stopping,
returned by \link{scoreSpectrum}}

\item{n.significant}{number of bins with statistically significant
enrichment}

\item{n.bins}{number of bins}
}
\value{
a three-dimensional binary vector with the following components:
\tabular{rl}{
  \code{coordinate 1} \tab \code{adj.r.squared >= 0.4}\cr
  \code{coordinate 2} \tab \code{consistency.score.n > 1000000}\cr
  \code{coordinate 3} \tab \code{n.significant >= floor(n.bins / 10)}
}
}
\description{
Spectra can be classified based on the aggregate spectrum classifier score.
If \code{sum(score) == 3} spectrum considered non-random, random otherwise.
}
\examples{
n.bins <- 40

# random spectrum
random.sp <- scoreSpectrum(runif(n = n.bins, min = -1, max = 1),
  max.model.degree = 1)
score <- spectrumClassifier(
  adj.r.squared(random.sp), degree(random.sp),
  slope(random.sp), consistency.score.n(random.sp), 0, n.bins
)
sum(score)

# non-random linear spectrum with strong noise component
signal <- seq(-1, 0.99, 2 / 40)
noise <- rnorm(n = 40, mean = 0, sd = 0.5)
linear.sp <- scoreSpectrum(signal + noise, max.model.degree = 1,
  max.cs.permutations = 100000)
score <- spectrumClassifier(
  adj.r.squared(linear.sp), degree(linear.sp),
  slope(linear.sp), consistency.score.n(linear.sp), 10, n.bins
)
sum(score)
\dontrun{
# non-random linear spectrum with weak noise component
signal <- seq(-1, 0.99, 2 / 40)
noise <- rnorm(n = 40, mean = 0, sd = 0.2)
linear.sp <- scoreSpectrum(signal + noise, max.model.degree = 1,
  max.cs.permutations = 100000)
score <- spectrumClassifier(
  adj.r.squared(linear.sp), degree(linear.sp),
  slope(linear.sp), consistency.score.n(linear.sp), 10, n.bins
)
sum(score)
}

# non-random quadratic spectrum with strong noise component
signal <- seq(-1, 0.99, 2 / 40)^2 - 0.5
noise <- rnorm(n = 40, mean = 0, sd = 0.2)
quadratic.sp <- scoreSpectrum(signal + noise, max.model.degree = 2,
  max.cs.permutations = 100000)
score <- spectrumClassifier(
  adj.r.squared(quadratic.sp), degree(quadratic.sp),
  slope(quadratic.sp), consistency.score.n(quadratic.sp), 10, n.bins
)
sum(score)
\dontrun{
# non-random quadratic spectrum with weak noise component
signal <- seq(-1, 0.99, 2 / 40)^2 - 0.5
noise <- rnorm(n = 40, mean = 0, sd = 0.1)
quadratic.sp <- scoreSpectrum(signal + noise, max.model.degree = 2)
score <- spectrumClassifier(
  adj.r.squared(quadratic.sp), degree(quadratic.sp),
  slope(quadratic.sp), consistency.score.n(quadratic.sp), 10, n.bins
)
sum(score)
}
}
\seealso{
Other SPMA functions: \code{\link{runKmerSPMA}},
  \code{\link{runMatrixSPMA}}, \code{\link{scoreSpectrum}},
  \code{\link{subdivideData}}
}
\concept{SPMA functions}
