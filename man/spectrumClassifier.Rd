% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spectrum.R
\name{spectrumClassifier}
\alias{spectrumClassifier}
\title{Simple spectrum classifier based on empirical thresholds}
\usage{
spectrumClassifier(
  adj_r_squared,
  degree,
  slope,
  consistency_score_n,
  n_significant,
  n_bins
)
}
\arguments{
\item{adj_r_squared}{adjusted \eqn{R^2} of polynomial model, returned by
\link{scoreSpectrum}}

\item{degree}{degree of polynomial, returned by \link{scoreSpectrum}}

\item{slope}{coefficient of the linear term of the polynomial model
(spectrum "direction"),
returned by \link{scoreSpectrum}}

\item{consistency_score_n}{number of performed permutations before
early stopping,
returned by \link{scoreSpectrum}}

\item{n_significant}{number of bins with statistically significant
enrichment}

\item{n_bins}{number of bins}
}
\value{
a three-dimensional binary vector with the following components:
\tabular{rl}{
  \code{coordinate 1} \tab \code{adj_r_squared >= 0.4}\cr
  \code{coordinate 2} \tab \code{consistency_score_n > 1000000}\cr
  \code{coordinate 3} \tab \code{n_significant >= floor(n_bins / 10)}
}
}
\description{
Spectra can be classified based on the aggregate spectrum classifier score.
If \code{sum(score) == 3} spectrum considered non-random, random otherwise.
}
\examples{
n_bins <- 40

# random spectrum
random_sp <- scoreSpectrum(runif(n = n_bins, min = -1, max = 1),
  max_model_degree = 1)
score <- spectrumClassifier(
  spectrumAdjRSquared(random_sp), spectrumDegree(random_sp),
  spectrumSlope(random_sp), spectrumConsistencyScoreN(random_sp), 0, n_bins
)
sum(score)

# non-random linear spectrum with strong noise component
signal <- seq(-1, 0.99, 2 / 40)
noise <- rnorm(n = 40, mean = 0, sd = 0.5)
linear_sp <- scoreSpectrum(signal + noise, max_model_degree = 1,
  max_cs_permutations = 100000)
score <- spectrumClassifier(
  spectrumAdjRSquared(linear_sp), spectrumDegree(linear_sp),
  spectrumSlope(linear_sp), spectrumConsistencyScoreN(linear_sp), 10, n_bins
)
sum(score)
\dontrun{
# non-random linear spectrum with weak noise component
signal <- seq(-1, 0.99, 2 / 40)
noise <- rnorm(n = 40, mean = 0, sd = 0.2)
linear_sp <- scoreSpectrum(signal + noise, max_model_degree = 1,
  max_cs_permutations = 100000)
score <- spectrumClassifier(
  spectrumAdjRSquared(linear_sp), spectrumDegree(linear_sp),
  spectrumSlope(linear_sp), spectrumConsistencyScoreN(linear_sp), 10, n_bins
)
sum(score)
}

# non-random quadratic spectrum with strong noise component
signal <- seq(-1, 0.99, 2 / 40)^2 - 0.5
noise <- rnorm(n = 40, mean = 0, sd = 0.2)
quadratic_sp <- scoreSpectrum(signal + noise, max_model_degree = 2,
  max_cs_permutations = 100000)
score <- spectrumClassifier(
  spectrumAdjRSquared(quadratic_sp), spectrumDegree(quadratic_sp),
  spectrumSlope(quadratic_sp), spectrumConsistencyScoreN(quadratic_sp), 10, n_bins
)
sum(score)
\dontrun{
# non-random quadratic spectrum with weak noise component
signal <- seq(-1, 0.99, 2 / 40)^2 - 0.5
noise <- rnorm(n = 40, mean = 0, sd = 0.1)
quadratic_sp <- scoreSpectrum(signal + noise, max_model_degree = 2)
score <- spectrumClassifier(
  spectrumAdjRSquared(quadratic_sp), spectrumDegree(quadratic_sp),
  spectrumSlope(quadratic_sp), spectrumConsistencyScoreN(quadratic_sp), 10, n_bins
)
sum(score)
}
}
\seealso{
Other SPMA functions: 
\code{\link{runKmerSPMA}()},
\code{\link{runMatrixSPMA}()},
\code{\link{scoreSpectrum}()},
\code{\link{subdivideData}()}
}
\concept{SPMA functions}
